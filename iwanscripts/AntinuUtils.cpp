// A fit in energy for signal and a background
#include <string>
#include <vector>
#include <math.h>
#include <Rand.h>
#include <fstream>
#include <iostream>

#include <TCanvas.h>
#include <ROOTNtuple.h>
#include <TRandom3.h>
#include <TH1D.h>
#include <TTree.h>
#include <TNtuple.h>

#include <BinnedED.h>
#include <Histogram.h>
#include <BinnedEDGenerator.h>
#include <SystematicManager.h>
#include <BinnedNLLH.h>
#include <FitResult.h>
#include <Minuit.h>
#include <DistTools.h>
#include <Minuit.h>
#include <Convolution.h>
#include <Scale.h>
#include <BoolCut.h>
#include <BoxCut.h>
#include <Gaussian.h>
#include <ParameterDict.h>
#include <ContainerTools.hpp>
#include <NuOsc.h>
#include <SurvProb.h>

bool test_file_exists(const std::string& name) {
    bool flag = false;
    if (FILE *file = fopen(name.c_str(), "r")) {
        fclose(file);
        flag = true;
    }
    else {
        flag = false;
    }
    return flag;
}

void readConstraintsInfoFile(const std::string &runConstraintsInfoFileName, std::string reactor_name, Double_t &fit_mean, Double_t &fit_mean_err, Double_t &fit_sigma, Double_t &fit_sigma_err, int &constrain_on ) {
    //
    // Read constraints info from text file - generated by the 'passes_plot' script which fits number of events per year per reactor
    // reads one at a time, searches for a reactor name if a match is found the fit information is returned
    //

    std::ifstream in;
    in.open(runConstraintsInfoFileName.c_str());
    //std::cout << "opening file: " << runConstraintsInfoFileName.c_str() << std::endl;

    std::string reactor_name2,fit_mean_s,fit_mean_err_s,fit_sigma_s,fit_sigma_err_s,constrain_on_s;
    ULong64_t line_no = 0, count = 0;

    // read until end of file.
    while(in.good()){
        std::getline(in,reactor_name2,',');
        std::getline(in,fit_mean_s,',');
        std::getline(in,fit_mean_err_s,',');
        std::getline(in,fit_sigma_s,',');
        std::getline(in,fit_sigma_err_s,',');
        std::getline(in,constrain_on_s,'\n');

        if (line_no>0){ //skip csv header
            if (strcmp(reactor_name.c_str(),reactor_name2.c_str())==0) {
                fit_mean = atof(fit_mean_s.c_str());
                fit_mean_err = atof(fit_mean_err_s.c_str());
                fit_sigma = atof(fit_sigma_s.c_str());
                fit_sigma_err = atof(fit_sigma_err_s.c_str());
                constrain_on = atoi(constrain_on_s.c_str());
                count++;
                //std::cout << "v: reactor_name: " << reactor_names[line_no-1] << ", distance: " << distances[line_no-1] << ", reactor_type: " << reactor_types[line_no-1] << ", n_core: " << n_cores[line_no-1] << ", power: " << powers[line_no-1] << ", power_err: " << power_errs[line_no-1] << std::endl; //debug check ('-1' for header)
            }
        }
        line_no++;
    }
    in.close();

    // if no reactor is found, or if more than one reactor of the same name is found, show an error
    if (count>1){
        printf("Error: More than 1 of the reactor found, %s (times: %llu)\n", reactor_name.c_str(), count);
	exit(1);
    }
    if (count==0){
        printf("Error: Reactor not found in constraint info file, %s\n", reactor_name.c_str());
	exit(1);
    }
    //if (count==1)
    //    printf("Reactor found %s\n", reactor_name.c_str());

    // print out read info
    //printf("reactor_name:%s, fit_mean: %.3f, fit_mean_err: %.3f, fit_sigma: %.3f, fit_sigma_err: %.3f\n", reactor_name.c_str(), fit_mean, fit_mean_err, fit_sigma, fit_sigma_err);
}

void readInfoFile(const std::string &runInfoFileName, std::vector<std::string> &reactor_names, std::vector<Double_t> &distances, std::vector<std::string> &reactor_types, std::vector<ULong64_t> &n_cores, std::vector<Double_t> &powers, std::vector<Double_t> &power_errs ) {
    //
    // Read couchDB run-info text file
    //

    std::ifstream in;
    in.open(runInfoFileName.c_str());
    //std::cout << "opening file: " << runInfoFileName.c_str() << std::endl;

    std::fill(reactor_names.begin(), reactor_names.end(), "");
    std::fill(distances.begin(), distances.end(), 0.);
    std::fill(reactor_types.begin(), reactor_types.end(), "");
    std::fill(n_cores.begin(), n_cores.end(), 0);
    std::fill(powers.begin(), powers.end(), 0.);
    std::fill(power_errs.begin(), power_errs.end(), 0.);

    std::string reactor_name,distance,reactor_type,n_core,power,power_err;
    ULong64_t line_no = 0;

    // read until end of file.
    while(in.good()){
        std::getline(in,reactor_name,',');
        std::getline(in,distance,',');
        std::getline(in,reactor_type,',');
        std::getline(in,n_core,',');
        std::getline(in,power,',');
        std::getline(in,power_err,'\n');

        if (line_no>0){ //skip csv header
            if (strcmp(reactor_name.c_str(),"")!=0) {
                reactor_names.push_back(reactor_name);
                distances.push_back(atof(distance.c_str()));
                reactor_types.push_back(reactor_type.c_str());
                n_cores.push_back(atoi(n_core.c_str()));
                powers.push_back(atof(power.c_str()));
                power_errs.push_back(atof(power_err.c_str()));

                //std::cout << "v: reactor_name: " << reactor_names[line_no-1] << ", distance: " << distances[line_no-1] << ", reactor_type: " << reactor_types[line_no-1] << ", n_core: " << n_cores[line_no-1] << ", power: " << powers[line_no-1] << ", power_err: " << power_errs[line_no-1] << std::endl; //debug check ('-1' for header)
            }
        }
        line_no++;
    }
    in.close();

    // print out read info
    //for (size_t i=0; i<(size_t)reactor_names.size(); i++)
    //    printf("i:%llu,reactor_names[i]:%s, distance: %.5f, type: %s, n_cores: %llu, power: %.5f, power_err: %.5f \n", i, reactor_names[i].c_str(), distances[i], reactor_types[i].c_str(), n_cores[i], powers[i], power_errs[i]);
}

void readParameterFile(const std::string &runParameterFileName, std::vector<Double_t> &s_12s, std::vector<Double_t> &d_21s, std::vector<size_t> &xbins, std::vector<size_t> &ybins, std::vector<Double_t> &s_13s) {
    // Read text file containing oscillation parameters
    std::ifstream in;
    in.open(runParameterFileName.c_str());
    //std::cout << "opening file: " << runParameterFileName.c_str() << std::endl;

    std::fill(s_12s.begin(), s_12s.end(), 0.);
    std::fill(d_21s.begin(), d_21s.end(), 0.);
    std::fill(xbins.begin(), xbins.end(), 0);
    std::fill(ybins.begin(), ybins.end(), 0);
    std::fill(s_13s.begin(), s_13s.end(), 0.);

    std::string s_12, d_21, xbin, ybin, s_13;
    ULong64_t line_no = 0;

    // read until end of file.
    // format of file: 'd_21,s_12,s_13\n'
    while(in.good()){
        std::getline(in,s_12,',');
        std::getline(in,d_21,',');
        std::getline(in,xbin,',');
        std::getline(in,ybin,',');
        std::getline(in,s_13,'\n');

        if (line_no>0){ //skip csv header
            if (strcmp(d_21.c_str(),"")!=0) {
                s_12s.push_back(atof(s_12.c_str()));
                d_21s.push_back(atof(d_21.c_str()));
                xbins.push_back(atoi(xbin.c_str()));
                ybins.push_back(atoi(ybin.c_str()));
                s_13s.push_back(atof(s_13.c_str()));

                //std::cout << "v: d_21: " << d_21s[line_no-1] << ", s_12: " << s_12s[line_no-1] << ", s_13: " << s_13s[line_no-1] << std::endl; //debug check ('-1' for header)
            }
        }
        line_no++;
    }
    in.close();

    // // print out read parameters
    // for (size_t i=0; i<(size_t)d_21s.size(); i++)
        // printf("i:%llu, d_21:%.5f, s_12:%.5f, s_13:%.5f\n", i, d_21s[i], s_12s[i], s_13s[i]);
}

void LHFit_initialise(BinnedED &data_set_pdf, const std::string &data_path, const double flux_data, const double e_min, const double e_max, const size_t n_bins){
    //
    // Load pdf's for reactor types
    // Load data pdf
    //

    printf("Begin init--------------------------------------\n");
    printf("LHFit_initialise...\n");

    // setup ntuple
    ObsSet data_rep(0);

    // *********************** setup data set PDF
    // set up binning
    data_set_pdf.SetObservables(data_rep);

    // set up binning
    AxisCollection axes;
    axes.AddAxis(BinAxis("ev_prompt_fit", e_min, e_max, n_bins));

    // load (oscillated) data ntuple
    TFile *f_in = new TFile(data_path.c_str());
    TTree *data_set_ntp = (TTree*)f_in->Get("nt");
    Double_t ev_energy_p1;
    data_set_ntp->SetBranchAddress("ev_fit_energy_p1", &ev_energy_p1);

    for(size_t j = 0; j < data_set_ntp->GetEntries(); j++){
        data_set_ntp->GetEntry(j);
        data_set_pdf.Fill(ev_energy_p1);
    }
    f_in->Close();
    data_set_pdf.Scale(1./flux_data);
    printf("data scale: %.5f\n",flux_data);

    printf("End init--------------------------------------\n");
}

void LHFit_initialise_kamland(BinnedED &data_set_pdf, const double e_min, const double e_max, const size_t n_bins){
    //
    // Load pdf's for reactor types
    // Load data pdf
    //

    printf("Begin init--------------------------------------\n");
    printf("LHFit_initialise...\n");

    char name[1000];

    // setup ntuple
    ObsSet data_rep(0);

    // *********************** setup data set PDF
    // set up binning
    data_set_pdf.SetObservables(data_rep);

    const int array_num = 13;
    double data_set_array[array_num] = {7, 11, 9, 8, 8, 4, 5, 2, 0, 0, 0, 0, 0};
    if (n_bins != array_num){
        std::cout<<"wrong number of bins!!"<<std::endl;
        exit(1);
    }
    std::vector<double> data_set_vector;
    for(size_t i = 0; i < array_num; i++)
        data_set_vector.push_back(data_set_array[i]);
    data_set_pdf.SetBinContents(data_set_vector);

    // load (oscillated) data ntuple
    data_set_pdf.SetObservables(data_rep);

    // *********************** finished loading data

    printf("End init--------------------------------------\n");
}

void LHFit_load_fake_data(BinnedED &data_set_pdf, const std::string &data_path, const double flux_data, const double e_min, const double e_max, const size_t n_bins){
    //
    // Load pdf's for reactor types
    // Load data pdf
    //

    printf("Begin init--------------------------------------\n");
    printf("LHFit_initialise...\n");
    
    // setup ntuple
    ObsSet data_rep(0);

    // *********************** setup data set PDF
    // set up binning
    data_set_pdf.SetObservables(data_rep);

    // set up binning
    AxisCollection axes;
    axes.AddAxis(BinAxis("ev_prompt_fit", e_min, e_max, n_bins));

    TFile *f_in = TFile::Open((data_path).c_str(),"READ");
    //Data
    TNtuple *datacontentNT = (TNtuple*) f_in->Get("databincontents");
    float Count;
    datacontentNT->SetBranchAddress("counts", &Count);
    std::vector<double> Datacontent;
    
    for(int i = 0; i < datacontentNT->GetEntries(); i++){
      datacontentNT->GetEntry(i);
      Datacontent.push_back(Count);
    }
    
    data_set_pdf.SetBinContents(Datacontent);
    
    f_in->Close();
  
    //data_set_pdf.Scale(1./flux_data);

    //printf("data scale: %.5f\n",flux_data);

    printf("End init--------------------------------------\n");
}

double CalculateSplitPdfTails(TTree *split_info_tree, BinnedED *reactor_osc_pdf, bool split_alpha_n_pdf_1st, bool split_alpha_n_pdf_2nd, double e_min, double e_max){

    Double_t end_point, A_fit, mu_fit, sigma_fit, split_hist_int, split_func_int;
    split_info_tree->SetBranchAddress("end_point", &end_point);
    split_info_tree->SetBranchAddress("A_fit", &A_fit);
    split_info_tree->SetBranchAddress("mu_fit", &mu_fit);
    split_info_tree->SetBranchAddress("sigma_fit", &sigma_fit);
    split_info_tree->SetBranchAddress("split_hist_int", &split_hist_int);
    split_info_tree->SetBranchAddress("split_func_int", &split_func_int);
    double split_norm_modification = 1.;
    if (split_alpha_n_pdf_1st){
        split_info_tree->GetEntry(0);
        TF1 * f_gaus = new TF1("f_gaus","gaus",end_point,e_max);
        f_gaus->SetParameters(A_fit,mu_fit,sigma_fit);
        //std::cout<<end_point<<"  "<<A_fit<<"  "<<mu_fit<<"  "<<sigma_fit<<"  "<<split_hist_int<<"  "<<split_func_int<<std::endl;
        std::vector<Double_t> end_point_vec;
        end_point_vec.push_back(end_point);
        const Histogram hist_temp = reactor_osc_pdf->GetHistogram();
        size_t end_point_bin = hist_temp.FindBin(end_point_vec);
        //std::cout<<" end_bin: "<<end_point_bin<<" end:point: "<<end_point_vec[0]<<std::endl;
        for (size_t bin = end_point_bin/*0*/ ; bin < reactor_osc_pdf->GetNBins() ; bin++){
          //std::cout<<bin<<"  "<<hist_temp.GetBinCentre(bin,0)<<"  content: "<<reactor_osc_pdf->GetBinContent(bin);
          //if (bin >= end_point_bin){
          reactor_osc_pdf->SetBinContent(bin,f_gaus->Eval(hist_temp.GetBinCentre(bin,0)));
          //std::cout<<"  ->  "<<reactor_osc_pdf->GetBinContent(bin)<<std::endl;
          //}else
          //std::cout<<""<<std::endl;
        }
        split_norm_modification = split_hist_int + split_func_int;
        std::cout<<"int scale factor: "<<split_norm_modification<<std::endl;
    }else if (split_alpha_n_pdf_2nd){
        split_info_tree->GetEntry(1);
        TF1 * f_gaus = new TF1("f_gaus","gaus",e_min,end_point);
        f_gaus->SetParameters(A_fit,mu_fit,sigma_fit);
        //std::cout<<end_point<<"  "<<A_fit<<"  "<<mu_fit<<"  "<<sigma_fit<<"  "<<split_hist_int<<"  "<<split_func_int<<std::endl;
        std::vector<Double_t> end_point_vec;
        end_point_vec.push_back(end_point);
        const Histogram hist_temp = reactor_osc_pdf->GetHistogram();
        size_t end_point_bin = hist_temp.FindBin(end_point_vec);
        for (size_t bin = 0 ; bin < end_point_bin ; bin++){
          reactor_osc_pdf->SetBinContent(bin,f_gaus->Eval(hist_temp.GetBinCentre(bin,0)));
          //reactor_osc_pdf->GetAxes().GetAxis(0).GetBinCentre(bin)));
        }
        split_norm_modification = split_hist_int + split_func_int;
        std::cout<<"int scale factor: "<<split_norm_modification<<std::endl;
    }
    return split_norm_modification;
}

